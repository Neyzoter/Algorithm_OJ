# 无重复字符的最长子串问题

给定一个字符串，找出不含有重复字符的最长子串的长度。

示例 1:

```
输入: "abcabcbb"
输出: 3 
解释: 无重复字符的最长子串是 "abc"，其长度为 3。
```

示例 2:

```
输入: "bbbbb"
输出: 1
解释: 无重复字符的最长子串是 "b"，其长度为 1。
```

示例 3:

```
输入: "pwwkew"
输出: 3
解释: 无重复字符的最长子串是 "wke"，其长度为 3。
     请注意，答案必须是一个子串，"pwke" 是一个子序列 而不是子串。
```


# 思路
## 哈希表法
1、从start=0,end=0开始遍历

2、在哈希表中查看是否有end下标对因的数值，如果有那么就更新start

start是end下标对因数值在哈希表中的下标和本次start的值中大的。

为什么要这么做呢？

如"abccb"。遍历到最后一个b时，可以查到哈希表中有b（第一个b），但是此时start时第二个c下标。所以可见不能小于start当前的下标，会造成来两个b中间有c重复。

3、将本次end对因的数值和下标+1put到哈希表中（会覆盖原来的<数值,下标+1>）

4、更新长度

*时间复杂度*:O(n)

*空间复杂度*:O(n)

## 暴力法
1、start=0,end=0开始遍历

2、每次end增加1次，就用一个idx_find下标来遍历从下标start到end前一个，是否有和end下标所在的数值相等的

如果相等就移动start到idx_find

3、如果最大长度end-start+1变大了，就更新长度

*时间复杂度*:O(n^2)

*空间复杂度*:O(1)

# 感悟
* 子序列和子串

子序列：子序列中的字符串不一定在原字符串中连在一起，而且是按照ASCII码顺序排序。

子串：子串中的字符串在原字符串中连在一起。