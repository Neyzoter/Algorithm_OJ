# 1、三数之和问题

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：

[

<<<<<<< HEAD
  [-1, 0, 1],
  
  [-1, -1, 2]
=======
# 思路
## 中心扩散法
分成两种情况，一种是奇数个，一种是偶数个。
>>>>>>> 609eeb95fc17dba009bbf94c36054d81fc7c0a98

]
# 2、思路
## 2.1 最终思路

1、nums排序

2、首先确定三个数中最小的数，得到其余两个数之和的目标，从左往右遍历

3、再使用双指针法得到中间数、最大数

*遍历过程注意点*

* 越大的数，下标一定比小的数下标大。

<<<<<<< HEAD
* 最小的数遍历到倒数第三个即可。
=======
*时间复杂度*:O(n^2)

*空间复杂度*:O(1)

## 动态规划法
1、先找长度1和2的回文子串，并存储在矩阵中

也就是先给(0,0)(1,1)(2,2)...(0,1)(1,2)(2,3)...赋值，false或者true。分别表示字符串下标i到j之间的部分是不是回文子串。

2、遍历长度3的回文子串，长度4的回文子串，以此类推

```
for(长度){
    for(下标遍历){
    	判断[本次下标,本次下标+长度]
    }
}
```

# 感悟
## 最长公共子串
给定两个字符串，求出它们之间最长的相同子字符串的长度。

**解决方法**

* 暴力法

以字符串中的每个字符作为子串的端点，判定以此为开始的子串的相同字符最长能达到的长度。。其实从表层上想，这个算法的复杂度应该只有O(n2)因为该算法把每个字符都成对相互比较一遍，但关键问题在于比较两个字符串的效率并非是O(1)，这也导致了实际的时间复杂度应该是满足Ω(n^2)和O(n^3)。

* 动态规划

在比较以i和j分别为起始点字符串时，有可能会进行i+1和j+1以及i+2和j+2位置的字符的比较；而在比较i+1和j+1分别为起始点字符串时，这些字符又会被比较一次了。也就是说该问题有非常相似的子问题，而子问题之间又有重叠，这就给动态规划法的应该提供了契机。













>>>>>>> 609eeb95fc17dba009bbf94c36054d81fc7c0a98

* 确定最小的数的时候，如果和前面一个的相同，可以直接跳过。

因为当前最小数后面遍历的数集合是前一个相同的数后面遍历的数集合的子集。

[-1,-1,-1,0,1,1,2]，可见第一个-1后面的数肯定比第二个-1后面的数多，是子集关系。第二个-1作为最小数所做的遍历结果，一定包含在第一个-1作为最小数所做的遍历结果当中。

*时间复杂度*:O(n^2)

*空间复杂度*:O(1)??
## 2.2 其他思路
### 2.2.1 步骤
1、nums排序

2、先确定三个数（小、中、大排序）的中间那个，得到其余的两个数相加需要多大。

3、开始向左边和右边遍历，寻找最小的值和最大的值。

### 2.2.2 说明

*问题*

需要考虑左边和右边遍历的数是否会影响到最终出来的结果是重复的，较麻烦。

*特点*

减少遍历的时间。

# 3、感悟
* 双指针法

目标：两个数相加和target相等，且找到的数不重复

方法：

1、排序数组

2、一个（min）从最小开始，一个（max）从最大开始。

3、如果相加大于target，则max减小，即max下标减小。

如果相加小于target，则min增大，即max下标增大。

4、如果相加等于target，则保存这组数。

双指针同时向对方靠拢，min下标变大，max下标变小。

同时，**为了防止重复**，如果max和上一个相等，则跳过，到达在下一个。min同理。

```Java
while(idx_mid<idx_max&&nums[idx_mid]==nums[idx_mid-1]) {
						idx_mid++;
					}
```