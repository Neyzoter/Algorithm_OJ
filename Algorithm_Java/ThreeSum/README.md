# 1、三数之和问题

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：

[

  [-1, 0, 1],
  
  [-1, -1, 2]

]
# 2、思路
## 2.1 最终思路

1、nums排序

2、首先确定三个数中最小的数，得到其余两个数之和的目标，从左往右遍历

3、再使用双指针法得到中间数、最大数

*遍历过程注意点*

* 越大的数，下标一定比小的数下标大。

* 最小的数遍历到倒数第三个即可。

* 确定最小的数的时候，如果和前面一个的相同，可以直接跳过。

因为当前最小数后面遍历的数集合是前一个相同的数后面遍历的数集合的子集。

[-1,-1,-1,0,1,1,2]，可见第一个-1后面的数肯定比第二个-1后面的数多，是子集关系。第二个-1作为最小数所做的遍历结果，一定包含在第一个-1作为最小数所做的遍历结果当中。

*时间复杂度*:O(n^2)

*空间复杂度*:O(1)??
## 2.2 其他思路
### 2.2.1 步骤
1、nums排序

2、先确定三个数（小、中、大排序）的中间那个，得到其余的两个数相加需要多大。

3、开始向左边和右边遍历，寻找最小的值和最大的值。

### 2.2.2 说明

*问题*

需要考虑左边和右边遍历的数是否会影响到最终出来的结果是重复的，较麻烦。

*特点*

减少遍历的时间。

# 3、感悟
* 双指针法

目标：两个数相加和target相等，且找到的数不重复

方法：

1、排序数组

2、一个（min）从最小开始，一个（max）从最大开始。

3、如果相加大于target，则max减小，即max下标减小。

如果相加小于target，则min增大，即max下标增大。

4、如果相加等于target，则保存这组数。

双指针同时向对方靠拢，min下标变大，max下标变小。

同时，**为了防止重复**，如果max和上一个相等，则跳过，到达在下一个。min同理。

```Java
while(idx_mid<idx_max&&nums[idx_mid]==nums[idx_mid-1]) {
						idx_mid++;
					}
```